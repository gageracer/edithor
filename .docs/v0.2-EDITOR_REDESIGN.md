# v0.2 Editor Redesign Architecture

**Version:** 0.2  
**Date:** 2025-12-02  
**Status:** Phase 1 Complete âœ…

---

## ğŸ“‹ Overview

Complete redesign of the chunking interface with a split-panel editor layout, real-time highlighting, and improved history management. This document serves as the reference architecture for implementing the new visual editor.

---

## ğŸ¨ Design Mockup Reference

### Layout Structure

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Stats Bar: 700 texts | 433 segments | 490 avg | 15 sessions | ... â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                              â”‚                                      â”‚
â”‚  Text Editor Panel           â”‚  Filter Settings Panel               â”‚
â”‚  - Line numbers              â”‚  - Current filter options            â”‚
â”‚  - Original text display     â”‚  - Marker pair configuration         â”‚
â”‚  - Highlighted segments      â”‚  - Character limits                  â”‚
â”‚  - Read-only result mode     â”‚  - Process button                    â”‚
â”‚                              â”‚  - [Show Original / Result] toggle   â”‚
â”‚                              â”‚                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  History Tabs: [text1] [text2] [text3] [text4] [text5] [text6] ... â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Features

1. **Diff-like highlighting** - Show which parts are selected by filters
2. **Toggle view** - Switch between original and chunked result
3. **Scrollable history tabs** - Horizontal scroll for many saved states
4. **Real-time stats** - Live metrics at the top
5. **Split panels** - Resizable editor and settings side-by-side

---

## ğŸ—ï¸ Technical Stack

### Current Technologies
- âœ… **Svelte 5** with runes ($state, $derived, $effect)
- âœ… **SvelteKit** for routing
- âœ… **TypeScript** for type safety
- âœ… **Tailwind CSS** for styling (already configured)
- âœ… **shadcn-svelte** UI components (Card, Button, Input, etc.)
- âœ… **Dexie.js** for IndexedDB storage (history persistence)
- âœ… **Vitest + Playwright** for testing

### New Dependencies

```json
{
  "dependencies": {
    "@codemirror/state": "^6.x",
    "@codemirror/view": "^6.x", 
    "@codemirror/language": "^6.x",
    "@codemirror/commands": "^6.x",
    "@codemirror/lang-markdown": "^6.x",
    "runed": "^0.37.0"
  }
}
```

### Why CodeMirror 6?
- âœ… Built-in line numbers
- âœ… Excellent performance with large texts
- âœ… Custom decorations/highlighting support
- âœ… Read-only mode for result view
- âœ… Extensible and well-maintained
- âœ… Works great with Svelte 5

### runed Library Usage

**Selected utilities from runed:**

| Utility | Purpose | Priority |
|---------|---------|----------|
| `Debounced` | Debounce auto-save operations | High |
| `useResizeObserver` | Make split panel resizable | Medium |
| `StateHistory` | Built-in undo/redo for editor | Low |
| `useIntersectionObserver` | Lazy load history tabs | Low |
| `watch` | React to filter changes | High |

**Note:** `PersistedState` from runed is **not needed** - we already have Dexie for persistent storage.

---

## ğŸ§© Component Architecture

### Component Hierarchy

```
routes/chunking/+page.svelte
â””â”€â”€ ChunkEditorLayout.svelte (Context Provider)
    â”œâ”€â”€ StatsBar.svelte (top)
    â”œâ”€â”€ SplitPanel.svelte (main content)
    â”‚   â”œâ”€â”€ EditorPanel.svelte (left)
    â”‚   â”‚   â”œâ”€â”€ CodeMirrorEditor.svelte
    â”‚   â”‚   â””â”€â”€ ViewToggleButton.svelte
    â”‚   â””â”€â”€ FilterPanel.svelte (right)
    â”‚       â”œâ”€â”€ FilterSettings.svelte
    â”‚       â”œâ”€â”€ MarkerPairConfig.svelte
    â”‚       â””â”€â”€ ProcessButton.svelte
    â””â”€â”€ HistoryTabs.svelte (bottom)
```

### Component Categories

#### **1. Small, Stateless Components (Props Only)**

These receive data via props and emit events. No context needed.

- **`StatsBar.svelte`**
  - Props: `{ totalChars, segmentCount, avgSize, sessionCount, totalWords }`
  - Displays metrics in a horizontal bar

- **`StatCard.svelte`**
  - Props: `{ label, value, icon? }`
  - Individual stat display component

- **`ViewToggleButton.svelte`**
  - Props: `{ mode: 'original' | 'result', onChange }`
  - Toggle button between original/result view

- **`HistoryTab.svelte`**
  - Props: `{ name, active, timestamp, onClick }`
  - Single tab item in history bar

#### **2. Medium Components (Context + Props)**

These use context for shared state but can accept configuration props.

- **`EditorPanel.svelte`**
  - Uses: `editorContext`
  - Manages CodeMirror instance and highlight decorations
  - Handles view mode switching
  - Applies Tailwind classes: `border rounded-lg bg-card`

- **`FilterPanel.svelte`**
  - Uses: `editorContext`
  - Contains filter configuration UI
  - Triggers processing on button click
  - Tailwind: `border rounded-lg bg-card p-6 space-y-4`

- **`HistoryTabs.svelte`**
  - Uses: `editorContext`
  - Horizontal scrollable tab bar
  - Loads history from Dexie
  - Tailwind: `overflow-x-auto flex gap-2 border-t pt-4`

- **`CodeMirrorEditor.svelte`**
  - Props: `{ content, readonly, highlights, lineNumbers }`
  - Events: `{ onChange }`
  - Wrapper around CodeMirror 6
  - Handles decoration lifecycle

#### **3. Large Container (Context Provider)**

- **`ChunkEditorLayout.svelte`**
  - Root component for the editor view
  - Provides `editorContext` to all children
  - Manages layout with Tailwind Grid/Flex
  - Handles keyboard shortcuts
  - Coordinates auto-save

---

## ğŸ”„ State Management

### Context Store: `editorContext.svelte.ts`

**Location:** `src/lib/contexts/editorContext.svelte.ts`

```typescript
import { setContext, getContext } from 'svelte';
import type { MarkerPair, ChunkingState, ChunkStats } from '$lib/types';
import { saveState, loadState, getAllStates } from '$lib/db/storage';
import { chunkText } from '$lib/utils/chunker';

const EDITOR_CONTEXT_KEY = Symbol('editorContext');

export class EditorContext {
  // Core reactive state
  currentText = $state<string>('');
  resultText = $state<string>('');
  viewMode = $state<'original' | 'result'>('original');
  
  // Chunking configuration
  markerPairs = $state<MarkerPair[]>([{
    id: 1,
    startMarker: "### Voice Script Segments",
    endMarker: "### Storyboard Images",
    patternTemplate: "**Segment %n:** (%d characters)",
    pattern: null,
    format: 'double-star'
  }]);
  maxCharacters = $state<number>(490);
  
  // History management
  historyStates = $state<ChunkingState[]>([]);
  currentHistoryId = $state<number | null>(null);
  isProcessing = $state<boolean>(false);
  
  // Computed values (derived state)
  stats = $derived.by(() => {
    const text = this.viewMode === 'original' ? this.currentText : this.resultText;
    const chars = text.length;
    const words = text.split(/\s+/).filter(w => w.length > 0).length;
    const segments = this.extractSegmentCount(text);
    const avgSize = segments > 0 ? Math.round(chars / segments) : 0;
    
    return {
      totalChars: chars,
      totalWords: words,
      segmentCount: segments,
      avgSize,
      sessionCount: this.historyStates.length
    };
  });
  
  highlightRanges = $derived.by(() => {
    // Calculate highlight ranges based on marker pairs
    return this.calculateHighlights(this.currentText, this.markerPairs);
  });
  
  // Methods
  async loadHistory() {
    this.historyStates = await getAllStates();
  }
  
  async loadHistoryItem(id: number) {
    const state = await loadState(id);
    if (state) {
      this.currentText = state.inputText;
      this.resultText = state.resultText || '';
      this.maxCharacters = state.maxCharacters;
      this.markerPairs = state.markerPairs.map((mp, idx) => ({
        ...mp,
        pattern: this.createPattern(mp.patternTemplate)
      }));
      this.currentHistoryId = id;
      this.viewMode = 'original';
    }
  }
  
  async saveToHistory(name?: string) {
    const id = await saveState(
      this.currentText,
      this.maxCharacters,
      this.markerPairs,
      name
    );
    await this.loadHistory();
    this.currentHistoryId = id;
  }
  
  async processChunking() {
    this.isProcessing = true;
    try {
      // Use existing chunking logic
      const chunks = await chunkText(this.currentText, {
        maxCharacters: this.maxCharacters,
        markerPairs: this.markerPairs
      });
      this.resultText = this.formatChunks(chunks);
      await this.saveToHistory('Processed');
    } finally {
      this.isProcessing = false;
    }
  }
  
  switchView(mode: 'original' | 'result') {
    this.viewMode = mode;
  }
  
  updateMarkerPair(id: number, updates: Partial<MarkerPair>) {
    const index = this.markerPairs.findIndex(mp => mp.id === id);
    if (index >= 0) {
      this.markerPairs[index] = { ...this.markerPairs[index], ...updates };
    }
  }
  
  addMarkerPair() {
    const newId = Math.max(...this.markerPairs.map(mp => mp.id), 0) + 1;
    this.markerPairs.push({
      id: newId,
      startMarker: "",
      endMarker: "",
      patternTemplate: "**Segment %n:** (%d characters)",
      pattern: null,
      format: 'double-star'
    });
  }
  
  removeMarkerPair(id: number) {
    if (this.markerPairs.length > 1) {
      this.markerPairs = this.markerPairs.filter(mp => mp.id !== id);
    }
  }
  
  // Helper methods
  private extractSegmentCount(text: string): number {
    // Count segments based on marker patterns
    let count = 0;
    for (const mp of this.markerPairs) {
      if (mp.pattern) {
        const matches = text.match(mp.pattern);
        count += matches?.length || 0;
      }
    }
    return count;
  }
  
  private calculateHighlights(text: string, markerPairs: MarkerPair[]) {
    // Return array of { from, to, class } for CodeMirror decorations
    const ranges: Array<{ from: number; to: number; class: string }> = [];
    // Implementation will use regex to find and mark segments
    return ranges;
  }
  
  private createPattern(template: string): RegExp | null {
    // Reuse existing pattern creation logic from ChunkingMode.svelte
    return null; // Placeholder
  }
  
  private formatChunks(chunks: any[]): string {
    // Format chunks into output text
    return chunks.map((c, i) => `**Segment ${i + 1}:** ${c.text}`).join('\n\n');
  }
}

// Context helpers
export function setEditorContext() {
  const ctx = new EditorContext();
  setContext(EDITOR_CONTEXT_KEY, ctx);
  return ctx;
}

export function getEditorContext(): EditorContext {
  return getContext(EDITOR_CONTEXT_KEY);
}
```

### Why This Approach?

âœ… **No prop drilling** - Context provides state to deeply nested components  
âœ… **Type-safe** - Full TypeScript with autocomplete  
âœ… **Reactive** - Svelte 5 runes provide fine-grained reactivity  
âœ… **Testable** - Can instantiate `EditorContext` in tests  
âœ… **Maintainable** - Clear separation of concerns  

---

## ğŸ¨ CodeMirror Integration

### Editor Setup

**File:** `src/lib/components/CodeMirrorEditor.svelte`

```typescript
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { EditorView, basicSetup } from '@codemirror/view';
  import { EditorState, StateField, StateEffect } from '@codemirror/state';
  import { Decoration, DecorationSet } from '@codemirror/view';
  import { markdown } from '@codemirror/lang-markdown';

  interface Props {
    content: string;
    readonly?: boolean;
    highlights?: Array<{ from: number; to: number; class: string }>;
    lineNumbers?: boolean;
    onChange?: (value: string) => void;
  }

  let { content, readonly = false, highlights = [], lineNumbers = true, onChange }: Props = $props();

  let editorElement: HTMLDivElement;
  let view: EditorView | undefined;

  // Highlight decoration field
  const highlightEffect = StateEffect.define<Array<{ from: number; to: number; class: string }>>();
  
  const highlightField = StateField.define<DecorationSet>({
    create() {
      return Decoration.none;
    },
    update(decorations, tr) {
      decorations = decorations.map(tr.changes);
      for (let effect of tr.effects) {
        if (effect.is(highlightEffect)) {
          const marks = effect.value.map(({ from, to, class: cls }) =>
            Decoration.mark({ class: cls }).range(from, to)
          );
          decorations = Decoration.set(marks, true);
        }
      }
      return decorations;
    },
    provide: f => EditorView.decorations.from(f)
  });

  onMount(() => {
    const state = EditorState.create({
      doc: content,
      extensions: [
        basicSetup,
        markdown(),
        highlightField,
        EditorView.lineNumbers.of(lineNumbers),
        EditorView.editable.of(!readonly),
        EditorView.updateListener.of(update => {
          if (update.docChanged && onChange) {
            onChange(update.state.doc.toString());
          }
        })
      ]
    });

    view = new EditorView({
      state,
      parent: editorElement
    });
  });

  // React to highlight changes
  $effect(() => {
    if (view && highlights) {
      view.dispatch({
        effects: highlightEffect.of(highlights)
      });
    }
  });

  // React to content changes
  $effect(() => {
    if (view && content !== view.state.doc.toString()) {
      view.dispatch({
        changes: { from: 0, to: view.state.doc.length, insert: content }
      });
    }
  });

  onDestroy(() => {
    view?.destroy();
  });
</script>

<div bind:this={editorElement} class="cm-editor-wrapper"></div>

<style>
  :global(.cm-editor-wrapper) {
    @apply border rounded-lg overflow-hidden;
  }
  
  :global(.cm-editor) {
    @apply h-full;
  }

  :global(.cm-scroller) {
    @apply font-mono text-sm;
  }

  /* Highlight styles */
  :global(.cm-segment-highlight) {
    @apply bg-blue-100 dark:bg-blue-900/30 border-l-2 border-blue-500;
  }

  :global(.cm-segment-active) {
    @apply bg-yellow-100 dark:bg-yellow-900/30 border-l-2 border-yellow-500;
  }
</style>
```

---

## ğŸ¨ Tailwind Styling Guide

### Design Tokens

```css
/* Primary colors from Tailwind */
- Background: bg-background
- Card: bg-card
- Border: border-border
- Text: text-foreground
- Muted: text-muted-foreground

/* Highlight colors */
- Selected segment: bg-blue-100 dark:bg-blue-900/30
- Active segment: bg-yellow-100 dark:bg-yellow-900/30
- Border accent: border-blue-500
```

### Layout Classes

```typescript
// Main layout
<div class="flex flex-col h-screen">
  <!-- Stats bar -->
  <div class="border-b bg-card px-6 py-3">...</div>
  
  <!-- Split panel -->
  <div class="flex-1 grid grid-cols-2 gap-4 p-4">
    <!-- Editor panel -->
    <div class="border rounded-lg bg-card p-4">...</div>
    
    <!-- Filter panel -->
    <div class="border rounded-lg bg-card p-6 space-y-4">...</div>
  </div>
  
  <!-- History tabs -->
  <div class="border-t bg-card px-4 py-3 overflow-x-auto">
    <div class="flex gap-2">...</div>
  </div>
</div>
```

---

## ğŸ”„ Data Flow

### User Journey

1. **Load/Create Text**
   - User navigates to `/chunking`
   - Can load from history or paste new text
   - Text appears in editor panel

2. **Configure Filters**
   - User adjusts marker pairs in filter panel
   - Changes are reactive via `editorContext`
   - Highlights update in real-time (derived state)

3. **Process**
   - User clicks "Process" button
   - `processChunking()` runs chunking algorithm
   - Result stored in `resultText`
   - Auto-saved to Dexie history

4. **View Results**
   - User toggles to "Result" view
   - Editor switches to readonly mode
   - Shows formatted chunk output

5. **History Management**
   - All states auto-saved to IndexedDB
   - History tabs show at bottom
   - Click tab to load previous state

### State Updates

```
User Action â†’ Context Method â†’ Rune Update â†’ Derived State â†’ UI Re-render
     â†“
  Auto-save (debounced) â†’ Dexie â†’ History Refresh
```

---

## ğŸ§ª Testing Strategy

### Test Files Structure

```
src/lib/contexts/
  â””â”€â”€ editorContext.test.ts (unit tests)

src/lib/components/
  â”œâ”€â”€ CodeMirrorEditor.test.ts
  â”œâ”€â”€ EditorPanel.test.ts
  â”œâ”€â”€ FilterPanel.test.ts
  â”œâ”€â”€ StatsBar.test.ts
  â””â”€â”€ HistoryTabs.test.ts

src/lib/components/
  â””â”€â”€ ChunkEditorLayout.integration.test.ts

e2e/
  â””â”€â”€ editor-workflow.spec.ts
```

### Test Coverage

#### Unit Tests
- âœ… Context state mutations
- âœ… Derived state calculations
- âœ… Pattern creation logic
- âœ… Highlight range calculation

#### Component Tests
- âœ… CodeMirror initialization
- âœ… Decoration updates
- âœ… Props handling
- âœ… Event emissions

#### Integration Tests
- âœ… Context â†’ Component communication
- âœ… History save/load
- âœ… Full processing workflow

#### E2E Tests
- âœ… Load text â†’ Configure â†’ Process â†’ View result
- âœ… History navigation
- âœ… View toggle
- âœ… Keyboard shortcuts

---

## ğŸ“ Implementation Phases

### **Phase 1: Foundation** âœ… (COMPLETED)

**Goal:** Set up infrastructure

- [x] Install CodeMirror + runed dependencies
- [x] Create `editorContext.svelte.ts`
- [x] Create basic `ChunkEditorLayout.svelte`
- [x] Build `CodeMirrorEditor.svelte` wrapper
- [x] Test CodeMirror integration works
- [x] Fix scroll independence bug

**Deliverable:** Editor renders with basic text display

**What Was Built:**
- âœ… Installed codemirror@6.0.2 + all view/state/language packages
- âœ… Installed runed@0.37.0
- âœ… Created `src/lib/contexts/editorContext.svelte.ts` with full reactive state management
- âœ… Created `src/lib/components/editor/` directory with all core components:
  - `ChunkEditorLayout.svelte` - Main container with context provider
  - `CodeMirrorEditor.svelte` - Editor wrapper with highlight support
  - `EditorPanel.svelte` - Left panel with editor and view toggle
  - `FilterPanel.svelte` - Right panel with settings
  - `StatsBar.svelte` - Top metrics display
  - `HistoryTabs.svelte` - Bottom history navigation
- âœ… Created test route `/chunking-v2` for testing
- âœ… Fixed Tailwind v4 compatibility (no @apply, using CSS variables)

**What Works:**
- âœ… Editor loads and displays with CodeMirror
- âœ… Line numbers show correctly
- âœ… Stats bar displays live metrics
- âœ… Filter panel allows configuration
- âœ… Marker pairs can be added/removed
- âœ… Character limit is adjustable
- âœ… Text can be entered in editor
- âœ… Process button triggers chunking
- âœ… View toggle switches between original/result
- âœ… History saves to IndexedDB (Dexie)
- âœ… Readonly mode works for result view
- âœ… Layout is responsive

**Test Results:**
- E2E Tests: 11/16 passing (69% pass rate)
  - âœ… Layout renders correctly
  - âœ… Settings work properly
  - âœ… Processing and view switching works
  - âœ… Button states are correct
  - âš ï¸ Some selector issues in stats tests (non-critical)
  - âš ï¸ History display timing issues (needs refinement)

**Bug Fixes:**
1. âœ… **Scroll Independence** - Fixed left and right panels scrolling together
   - Wrapped each panel in separate `overflow-auto` containers
   - Made panel headers non-scrollable with `flex-shrink-0`
   - Editor and filter now scroll independently

**Known Issues:**
1. Highlighting not yet fully implemented (ranges calculated but not tested)
2. Some E2E test selectors need adjustment for stats format
3. History tab display needs slight delay for IndexedDB write
4. Unit tests for context require Svelte browser environment (vitest browser mode)

**Files Created:**
```
src/lib/contexts/editorContext.svelte.ts
src/lib/contexts/editorContext.test.ts (needs browser mode)
src/lib/components/editor/ChunkEditorLayout.svelte
src/lib/components/editor/CodeMirrorEditor.svelte
src/lib/components/editor/EditorPanel.svelte
src/lib/components/editor/FilterPanel.svelte
src/lib/components/editor/StatsBar.svelte
src/lib/components/editor/HistoryTabs.svelte
src/routes/chunking-v2/+page.svelte
e2e/editor-v2.spec.ts
```

**Technical Notes:**
- Tailwind v4 doesn't support @apply in component styles
- Used CSS variables (--color-border, --color-muted, etc.) instead
- CodeMirror decorations use StateField for reactive highlights
- Context uses Svelte 5 runes ($state, $derived, $effect)
- All marker pair logic migrated from old ChunkingMode component

---

### **Phase 2: Core Components** (Days 3-4)

**Goal:** Build main UI pieces

- [ ] Build `EditorPanel.svelte` with highlighting
- [ ] Build `FilterPanel.svelte` (migrate existing logic)
- [ ] Create `StatsBar.svelte` with live metrics
- [ ] Implement `ViewToggleButton.svelte`
- [ ] Connect context to all components

**Deliverable:** Full UI layout with reactive state

---

### **Phase 3: History System** (Day 5)

**Goal:** Integrate persistence

- [ ] Build `HistoryTabs.svelte` with horizontal scroll
- [ ] Integrate with Dexie storage
- [ ] Add debounced auto-save with runed
- [ ] Test history load/save

**Deliverable:** Working history with persistence

---

### **Phase 4: Polish & Testing** (Days 6-7)

**Goal:** Production-ready quality

- [ ] Add resizable split panel (runed `useResizeObserver`)
- [ ] Optimize highlighting performance
- [ ] Add keyboard shortcuts (Cmd+P for process, Cmd+T for toggle)
- [ ] Write unit tests for context
- [ ] Write component tests
- [ ] Write integration tests
- [ ] Write E2E test for main workflow
- [ ] Performance audit
- [ ] Accessibility audit (ARIA labels, keyboard nav)

**Deliverable:** Tested, polished feature ready for production

---

## ğŸš€ Migration Strategy

### Coexistence Approach

1. Keep existing `/chunking` route as-is initially
2. Create new route `/chunking-v2` for new editor
3. Test and validate new editor
4. Once stable, replace old route
5. Archive old component files

### File Changes

**New Files:**
```
src/lib/contexts/editorContext.svelte.ts
src/lib/components/editor/ChunkEditorLayout.svelte
src/lib/components/editor/EditorPanel.svelte
src/lib/components/editor/FilterPanel.svelte
src/lib/components/editor/StatsBar.svelte
src/lib/components/editor/HistoryTabs.svelte
src/lib/components/editor/CodeMirrorEditor.svelte
src/lib/components/editor/ViewToggleButton.svelte
src/routes/chunking-v2/+page.svelte
```

**Modified Files:**
```
src/lib/db/storage.ts (add resultText field)
src/lib/types/index.ts (extend ChunkingState interface)
package.json (add CodeMirror + runed)
```

---

## âš¡ Performance Considerations

### Optimizations

1. **Large Text Handling**
   - CodeMirror handles large docs efficiently
   - Use virtual scrolling for history tabs (lazy load)
   - Debounce highlight calculations

2. **Highlight Updates**
   - Only recalculate on marker pair changes
   - Use `$derived.by()` for memoization
   - Batch decoration updates

3. **Auto-save**
   - Debounce with runed `Debounced` (2 second delay)
   - Only save when meaningful changes occur
   - Skip saves for empty/unchanged states

4. **History Loading**
   - Load list metadata first (names, timestamps)
   - Lazy load full text content on demand
   - Index on timestamp in Dexie

---

## ğŸ¯ Success Criteria

### Feature Complete When:

- âœ… User can load text and see it in editor with line numbers
- âœ… Filter changes update highlights in real-time
- âœ… Processing creates result that can be toggled
- âœ… History saves automatically and can be navigated
- âœ… Stats bar shows accurate live metrics
- âœ… All components are tested (>80% coverage)
- âœ… E2E test passes for full workflow
- âœ… Responsive on mobile/tablet/desktop
- âœ… Accessible (keyboard navigation, screen readers)

---

## ğŸ“š References

### Documentation Links

- [CodeMirror 6 Docs](https://codemirror.net/docs/)
- [runed Documentation](https://runed.dev)
- [Svelte 5 Runes](https://svelte.dev/docs/svelte/what-are-runes)
- [Dexie.js](https://dexie.org/)
- [Tailwind CSS](https://tailwindcss.com/)

### Internal Docs

- [Pattern Templates](./pattern-templates.md)
- [Mode Architecture](./MODE_ARCHITECTURE.md)
- [Project Overview](./PROJECT.md)

---

## ğŸ¤” Open Questions

1. **Resizable panels:** Use runed or CSS-only solution?
   - **Decision:** Start with CSS, add runed if needed

2. **Keyboard shortcuts:** Which ones to implement?
   - **Proposal:** Cmd/Ctrl+P (process), Cmd/Ctrl+T (toggle view), Cmd/Ctrl+S (save)

3. **Mobile experience:** How to handle split panel on mobile?
   - **Decision:** Stack vertically, add tabs to switch panels

4. **Highlight colors:** User customizable or fixed?
   - **Decision:** Fixed for v0.2, customizable in v0.3

---

## ğŸ“… Timeline

**Estimated:** 7 working days

- Phase 1: 2 days
- Phase 2: 2 days  
- Phase 3: 1 day
- Phase 4: 2 days

**Target Launch:** TBD

---

## âœ… Next Actions

1. Review and approve this architecture doc
2. Install dependencies (CodeMirror + runed)
3. Create feature branch: `feature/editor-v0.2`
4. Begin Phase 1 implementation
5. Daily progress updates

---

**Document Status:** âœ… Phase 1 Complete - Ready for Phase 2  
**Last Updated:** 2025-12-02 (Bug fix applied)  
**Phase 1 Completed By:** AI Assistant with user approval

---

## ğŸ‰ Phase 1 Summary

**Time Spent:** ~2.5 hours (including bug fix)  
**Pass Rate:** 11/16 E2E tests (69%)  
**Bug Fixes:** 1 critical scroll issue resolved  
**Status:** Ready for Phase 2 implementation

The foundation is solid and working. The editor loads, processes text, saves to history, and switches between views. Each panel now scrolls independently. Phase 2 will focus on refining the UI, fixing test selectors, and polishing the highlighting feature.

**Next Up:** Phase 2 - Core Components refinement and testing improvements
