<script lang="ts">
	import {
		Card,
		CardContent,
		CardDescription,
		CardFooter,
		CardHeader,
		CardTitle
	} from '$lib/components/ui/card';
	import TextInput from '$lib/components/TextInput.svelte';
	import { Button } from '$lib/components/ui/button';
	import { Label } from '$lib/components/ui/label';
	import { Input } from '$lib/components/ui/input';
	import { chunkText } from '$lib/utils/chunker';
	import type { Chunk, ChunkStats } from '$lib/types';

	interface MarkerPair {
		id: number;
		startMarker: string;
		endMarker: string;
		patternTemplate: string; // User-friendly pattern with %n or %d for numbers
		pattern: RegExp;
		format: 'double-star' | 'plain' | 'generic';
	}

	let inputText = $state('');
	let markerPairs = $state<MarkerPair[]>([
		{
			id: 1,
			startMarker: '**Segment 1:**',
			endMarker: '',
			patternTemplate: '**Segment %n:** (%n characters)',
			pattern: /\*\*Segment\s+\d+:\*\*\s*(\(\d+\s*characters\)\s*)?/gi,
			format: 'double-star'
		},
		{
			id: 2,
			startMarker: 'Segment 1:',
			endMarker: '',
			patternTemplate: 'Segment %n: (%n characters)',
			pattern: /(?<!\*\*)Segment\s+\d+:\s*(\(\d+\s+characters\))?/gi,
			format: 'plain'
		}
	]);
	let nextMarkerId = $state(3);
	let targetCharLimit = $state(500);
	let segments = $state<Chunk[]>([]);
	let stats = $state<ChunkStats | undefined>(undefined);
	let hasProcessed = $state(false);
	let beforeContent = $state('');
	let afterContent = $state('');

	function escapeRegex(str: string): string {
		return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}

	function addMarkerPair() {
		markerPairs.push({
			id: nextMarkerId,
			startMarker: '',
			endMarker: '',
			patternTemplate: '**Segment %n:** (%n characters)',
			pattern: /\*\*Segment\s+\d+:\*\*\s*(\(\d+\s*characters\)\s*)?/gi,
			format: 'double-star'
		});
		nextMarkerId++;
	}

	function removeMarkerPair(id: number) {
		if (markerPairs.length > 1) {
			markerPairs = markerPairs.filter((pair) => pair.id !== id);
		}
	}

	// Convert pattern template with %n/%d placeholders to regex
	function templateToRegex(template: string): RegExp {
		// First, replace %n or %d with a placeholder marker before escaping
		let pattern = template.replace(/%[nd]/g, '###NUMBER###');

		// Check if template has character count pattern
		const hasCharCount = pattern.includes('(###NUMBER### characters)');

		// If template has character count, remove it temporarily
		if (hasCharCount) {
			pattern = pattern.replace(/\s*\(###NUMBER### characters\)\s*/, '');
		}

		// Check if this is a plain "Segment" pattern (without **)
		const isPlainSegmentPattern = pattern.includes('Segment') && !pattern.includes('**');

		// Escape special regex characters
		pattern = escapeRegex(pattern);

		// Add negative lookbehind for plain Segment patterns to avoid matching inside **Segment**
		if (isPlainSegmentPattern) {
			pattern = '(?<!\\*\\*)' + pattern;
		}

		// Replace number placeholders with regex pattern for one or more digits
		pattern = pattern.replace(/###NUMBER###/g, '\\d+');

		// If there was a character count in the template, add it as optional with flexible whitespace
		if (hasCharCount) {
			pattern = pattern + '\\s*(\\(\\d+\\s+characters\\))?';
		}

		return new RegExp(pattern, 'gi');
	}

	function updateMarkerPattern(id: number, patternTemplate: string) {
		const pair = markerPairs.find((p) => p.id === id);
		if (!pair) return;

		pair.patternTemplate = patternTemplate;

		// Detect format based on pattern template
		if (patternTemplate.includes('**Segment')) {
			pair.format = 'double-star';
		} else if (patternTemplate.match(/Segment\s+%[nd]/)) {
			pair.format = 'plain';
		} else {
			pair.format = 'generic';
		}

		// Generate regex from template
		pair.pattern = templateToRegex(patternTemplate);
	}

	function extractSegmentedSection(
		text: string,
		startMarker: string,
		sectionEndMarker: string
	): {
		before: string;
		segmented: string;
		after: string;
	} {
		// Find the start marker
		const startPattern = escapeRegex(startMarker);
		const startMatch = text.match(new RegExp(startPattern, 'i'));

		if (!startMatch) {
			return { before: text, segmented: '', after: '' };
		}

		const startIndex = startMatch.index!;

		// Only look for section end marker if it's specified and meaningful
		// Don't use \n as section delimiter - that's for per-segment delimiting
		if (sectionEndMarker && sectionEndMarker.trim() !== '' && sectionEndMarker !== '\\n') {
			// Find the section end marker
			const endPattern = escapeRegex(sectionEndMarker);
			const endMatch = text.substring(startIndex).match(new RegExp(endPattern, 'i'));

			if (endMatch) {
				const endIndex = startIndex + endMatch.index!;
				return {
					before: text.substring(0, startIndex),
					segmented: text.substring(startIndex, endIndex),
					after: text.substring(endIndex)
				};
			}
		}

		// No meaningful section end marker, take everything after start
		return {
			before: text.substring(0, startIndex),
			segmented: text.substring(startIndex),
			after: ''
		};
	}

	function extractSegmentContentUnified(
		segmentedSection: string,
		patterns: RegExp[],
		endMarker: string
	): { segments: string[]; trailingContent: string } {
		const segments: string[] = [];

		// Find all marker matches from ALL patterns with their positions
		const markers: Array<{ index: number; match: string; patternIndex: number }> = [];

		patterns.forEach((pattern, patternIndex) => {
			let match;
			const globalPattern = new RegExp(pattern.source, 'gi');

			while ((match = globalPattern.exec(segmentedSection)) !== null) {
				markers.push({
					index: match.index,
					match: match[0],
					patternIndex
				});
			}
		});

		// If no markers found, return empty
		if (markers.length === 0) {
			return { segments: [], trailingContent: '' };
		}

		// Sort markers by position (so we process them in document order)
		markers.sort((a, b) => a.index - b.index);

		// Determine if we should use end marker or next segment marker
		const useEndMarker = endMarker && endMarker.trim() !== '';

		// Extract content from each marker to its end marker or next segment
		for (let i = 0; i < markers.length; i++) {
			const currentMarker = markers[i];
			const nextMarker = markers[i + 1];

			// Start after the current marker
			const contentStart = currentMarker.index + currentMarker.match.length;

			let content: string;

			if (useEndMarker) {
				// Use the specified end marker
				let endPattern: RegExp;
				if (endMarker === '\\n') {
					endPattern = /\n\n/; // Double newline (blank line)
				} else {
					endPattern = new RegExp(escapeRegex(endMarker), 'i');
				}

				// Find the end marker after this start marker
				const remainingText = segmentedSection.substring(contentStart);
				const endMatch = remainingText.match(endPattern);

				if (endMatch) {
					// Extract content up to the end marker
					content = remainingText.substring(0, endMatch.index).trim();
				} else {
					// No end marker found, go to next segment or end of text
					const contentEnd = nextMarker ? nextMarker.index : segmentedSection.length;
					content = segmentedSection.substring(contentStart, contentEnd).trim();
				}
			} else {
				// Empty end marker: run until next segment marker
				const contentEnd = nextMarker ? nextMarker.index : segmentedSection.length;
				content = segmentedSection.substring(contentStart, contentEnd).trim();
			}

			if (content.length > 0) {
				segments.push(content);
			}
		}

		// Extract trailing content after the last segment marker
		const lastMarker = markers[markers.length - 1];
		const lastContentStart = lastMarker.index + lastMarker.match.length;

		// Find where the last segment content ends
		let lastSegmentEnd = lastContentStart;
		if (useEndMarker) {
			let endPattern: RegExp;
			if (endMarker === '\\n') {
				endPattern = /\n\n/; // Double newline (blank line)
			} else {
				endPattern = new RegExp(escapeRegex(endMarker), 'i');
			}
			const remainingText = segmentedSection.substring(lastContentStart);
			const endMatch = remainingText.match(endPattern);
			if (endMatch && endMatch.index !== undefined) {
				lastSegmentEnd = lastContentStart + endMatch.index + endMatch[0].length;
			} else {
				lastSegmentEnd = segmentedSection.length;
			}
		} else {
			lastSegmentEnd = segmentedSection.length;
		}

		// Everything after the last segment is trailing content
		const trailingContent = segmentedSection.substring(lastSegmentEnd).trim();

		return { segments, trailingContent };
	}

	function refactorSegments() {
		if (!inputText.trim()) {
			alert('Please enter segmented text to refactor.');
			return;
		}

		// Validate that at least one marker pair has values
		const validPairs = markerPairs.filter((pair) => pair.startMarker.trim());
		if (validPairs.length === 0) {
			alert('Please specify at least one start marker.');
			return;
		}

		try {
			// DIAGNOSTIC: Log patterns being used
			console.log('ðŸ” Refactoring with patterns:');
			validPairs.forEach((pair, i) => {
				console.log(`  Pattern ${i + 1} [${pair.format}]:`, pair.pattern);
				console.log(`    Template: "${pair.patternTemplate}"`);
			});

			// Use the first valid marker pair to find the segmented section boundaries
			const firstPair = validPairs[0];
			const { before, segmented, after } = extractSegmentedSection(
				inputText,
				firstPair.startMarker,
				firstPair.endMarker
			);

			if (!segmented) {
				alert('No segments found. Check your marker formats.');
				return;
			}

			// Store before/after content
			beforeContent = before;
			afterContent = after;

			// Collect all patterns from valid pairs
			const allPatterns = validPairs.map((pair) => pair.pattern);

			// DIAGNOSTIC: Test patterns on sample text
			const sampleBold = '**Segment 1:** (250 characters)';
			const samplePlain = 'Segment 1: (250 characters)';
			console.log('ðŸ§ª Pattern test:');
			allPatterns.forEach((pattern, i) => {
				console.log(`  Pattern ${i + 1}:`);
				console.log(`    Matches "${sampleBold}": ${pattern.test(sampleBold)}`);
				pattern.lastIndex = 0; // Reset regex
				console.log(`    Matches "${samplePlain}": ${pattern.test(samplePlain)}`);
				pattern.lastIndex = 0; // Reset regex
			});

			// Use end marker from first valid pair (they should all be the same)
			const endMarker = firstPair.endMarker;

			// Extract segments using unified approach (handles all patterns together)
			const { segments: allSegmentContents, trailingContent } = extractSegmentContentUnified(
				segmented,
				allPatterns,
				endMarker
			);

			// DIAGNOSTIC: Log extraction results
			console.log(`ðŸ“Š Extracted ${allSegmentContents.length} segments`);
			if (trailingContent) {
				console.log(`ðŸ“„ Trailing content: ${trailingContent.length} characters`);
			}

			if (allSegmentContents.length === 0) {
				console.error('âŒ No segments extracted!');
				alert('No segments found. Check your marker formats.');
				return;
			}

			console.log(`âœ… Successfully extracted ${allSegmentContents.length} segments`);

			// Append trailing content to afterContent
			if (trailingContent) {
				afterContent = after + '\n\n' + trailingContent;
			}

			// Combine all segment content into one continuous text
			const combinedContent = allSegmentContents.join(' ');

			// Re-chunk the entire combined content using the main chunking algorithm
			const result = chunkText(combinedContent, { maxCharacters: targetCharLimit });

			// Create segments with sequential numbering
			segments = result.chunks.map((chunk, index) => ({
				id: index + 1,
				content: chunk.content,
				characterCount: chunk.characterCount,
				sentenceCount: chunk.sentenceCount
			}));

			// Calculate stats
			const totalChars = segments.reduce((sum, chunk) => sum + chunk.characterCount, 0);
			const avgSize = Math.round(totalChars / segments.length);
			const sizes = segments.map((c) => c.characterCount);

			stats = {
				totalChunks: segments.length,
				totalCharacters: totalChars,
				averageChunkSize: avgSize,
				largestChunk: Math.max(...sizes),
				smallestChunk: Math.min(...sizes)
			};

			hasProcessed = true;

			// Scroll to preview
			setTimeout(() => {
				document.getElementById('refactor-preview-section')?.scrollIntoView({
					behavior: 'smooth',
					block: 'start'
				});
			}, 100);
		} catch (error) {
			console.error('Error refactoring segments:', error);
			alert('Failed to refactor segments. Please check your input format and markers.');
		}
	}

	function handleTextChange(text: string) {
		inputText = text;
		if (hasProcessed) {
			hasProcessed = false;
			segments = [];
			stats = undefined;
			beforeContent = '';
			afterContent = '';
		}
	}

	function exportAsText(): string {
		let output = beforeContent;

		// Determine format from the first valid marker pair
		const formatPair = markerPairs.find((p) => p.startMarker.trim());
		const format = formatPair?.format || 'double-star';

		segments.forEach((segment) => {
			// Format the segment marker based on detected format
			if (format === 'double-star') {
				output += `**Segment ${segment.id}:** (${segment.characterCount} characters)\n\n`;
			} else if (format === 'plain') {
				output += `Segment ${segment.id}: (${segment.characterCount} characters)\n\n`;
			} else {
				output += `Segment ${segment.id}:\n\n`;
			}
			output += segment.content + '\n\n';
		});

		output += afterContent;

		return output;
	}

	function downloadRefactored() {
		const content = exportAsText();
		const blob = new Blob([content], { type: 'text/plain' });
		const url = URL.createObjectURL(blob);
		const link = document.createElement('a');
		link.href = url;
		link.download = 'refactored-segments.txt';
		link.click();
		URL.revokeObjectURL(url);
	}

	function copyToClipboard() {
		const content = exportAsText();
		navigator.clipboard
			.writeText(content)
			.then(() => {
				alert('Copied to clipboard!');
			})
			.catch((err) => {
				console.error('Failed to copy:', err);
				alert('Failed to copy to clipboard');
			});
	}

	let canProcess = $derived(
		inputText.trim().length > 0 && markerPairs.some((pair) => pair.startMarker.trim().length > 0)
	);
</script>

<div class="space-y-8">
	<!-- Input Card -->
	<Card>
		<CardHeader>
			<CardTitle>Input Segmented Text</CardTitle>
			<CardDescription>
				Paste your full document with segments marked like "**Segment 1:** (487 characters)"
			</CardDescription>
		</CardHeader>
		<CardContent>
			<TextInput bind:value={inputText} onTextChange={handleTextChange} />
		</CardContent>
	</Card>

	<!-- Settings Card -->
	<Card>
		<CardHeader>
			<CardTitle>Refactoring Settings</CardTitle>
			<CardDescription>Define where segmentation starts and ends in your document</CardDescription>
		</CardHeader>
		<CardContent class="space-y-6">
			<!-- Marker Configuration -->
			<div class="space-y-4">
				<div class="space-y-2 mb-4">
					<div class="flex items-center justify-between">
						<Label>Segment Marker Patterns</Label>
						<Button onclick={addMarkerPair} variant="outline" size="sm">+ Add Another Format</Button>
					</div>
					<p class="text-xs text-muted-foreground">
						Define how segments are marked in your text. Use <code class="px-1 py-0.5 bg-muted rounded">%n</code> or <code class="px-1 py-0.5 bg-muted rounded">%d</code> in patterns to match any number (e.g., Segment 1, Segment 22, Segment 100).
					</p>
					<p class="text-xs text-emerald-600 dark:text-emerald-500">
						âœ… Both formats work together! Plain pattern automatically ignores bold markers (uses negative lookbehind). Safe for mixed documents.
					</p>
				</div>

				{#each markerPairs as pair, index (pair.id)}
					<div class="space-y-3 p-4 border rounded-lg">
						<div class="flex items-center justify-between">
							<span class="text-sm font-medium">Format {index + 1}</span>
							{#if markerPairs.length > 1}
								<Button
									onclick={() => removeMarkerPair(pair.id)}
									variant="ghost"
									size="sm"
									class="h-6 w-6 p-0"
								>
									Ã—
								</Button>
							{/if}
						</div>

						<div class="space-y-2">
							<Label>Start Marker Example</Label>
							<Input
								id="start-marker-{pair.id}"
								type="text"
								bind:value={pair.startMarker}
								placeholder="**Segment 1:** or Segment 1:"
								class="mb-2"
							/>
							<p class="text-xs text-muted-foreground">
								Example of one marker from your text (for reference only)
							</p>
							<div class="text-xs text-muted-foreground font-medium mt-3">
								<Label>Pattern Template:</Label>
							</div>
							<Input
								id="pattern-template-{pair.id}"
								type="text"
								bind:value={pair.patternTemplate}
								onchange={() => updateMarkerPattern(pair.id, pair.patternTemplate)}
								placeholder="**Segment %n:** (%n characters)"
								class="font-mono text-sm"
							/>
							<p class="text-xs text-muted-foreground">
								Use <code class="px-1 py-0.5 bg-muted rounded">%n</code> or <code class="px-1 py-0.5 bg-muted rounded">%d</code> as placeholders for any number. Character count is automatically optional. Be specific to avoid matching unintended text.
							</p>
						</div>

						<div class="space-y-2">
							<Label>End Marker</Label>
							<Input
								id="end-marker-{pair.id}"
								type="text"
								bind:value={pair.endMarker}
								placeholder="--- or next segment start"
							/>
							<p class="text-xs text-muted-foreground">
								Per-segment delimiter: Use <code class="px-1 py-0.5 bg-muted rounded">\n</code> for blank line between segments. Leave empty to run segments until next marker. Content after last segment is preserved.
							</p>
						</div>
					</div>
				{/each}
			</div>

			<!-- Character Limit -->
			<div class="space-y-2">
				<div class="flex items-center justify-between">
					<Label>Target Character Limit per Segment</Label>
				</div>
				<Input
					id="char-limit"
					type="number"
					min={50}
					max={2000}
					bind:value={targetCharLimit}
					class="max-w-[200px]"
				/>
				<p class="text-xs text-muted-foreground">
					Segments will be adjusted to match this limit while preserving sentence boundaries
				</p>
			</div>

			<!-- Process Button -->
			<div class="flex justify-center">
				<Button onclick={refactorSegments} variant="outline" disabled={!canProcess}>
					âœ¨ Refactor Segments
				</Button>
			</div>
		</CardContent>
	</Card>

	<!-- Preview Card -->
	{#if hasProcessed || segments.length > 0}
		<div id="refactor-preview-section">
			<Card>
				<CardHeader>
					<CardTitle>Refactored Segments</CardTitle>
					<CardDescription>
						{#if segments.length > 0}
							Your text has been refactored into {segments.length}
							{segments.length === 1 ? 'segment' : 'segments'}
						{:else}
							Your refactored segments will appear here
						{/if}
					</CardDescription>
				</CardHeader>
				<CardContent>
					{#if stats}
						<!-- Statistics -->
						<div class="mb-6 grid grid-cols-5 gap-4">
							<div class="rounded-lg border bg-card p-4 text-center">
								<div class="text-2xl font-bold">{stats.totalChunks}</div>
								<div class="text-xs text-muted-foreground">Total Segments</div>
							</div>
							<div class="rounded-lg border bg-card p-4 text-center">
								<div class="text-2xl font-bold">{stats.averageChunkSize}</div>
								<div class="text-xs text-muted-foreground">Avg Characters</div>
							</div>
							<div class="rounded-lg border bg-card p-4 text-center">
								<div class="text-2xl font-bold">{stats.largestChunk}</div>
								<div class="text-xs text-muted-foreground">Largest</div>
							</div>
							<div class="rounded-lg border bg-card p-4 text-center">
								<div class="text-2xl font-bold">{stats.smallestChunk}</div>
								<div class="text-xs text-muted-foreground">Smallest</div>
							</div>
							<div class="rounded-lg border bg-card p-4 text-center">
								<div class="text-2xl font-bold">{stats.totalCharacters.toLocaleString()}</div>
								<div class="text-xs text-muted-foreground">Total Chars</div>
							</div>
						</div>
					{/if}

					<!-- Segments Preview -->
					<div class="space-y-4 max-h-[600px] overflow-y-auto">
						{#each segments as segment, index (index)}
							<div class="rounded-lg border bg-card p-4">
								<div class="mb-2 flex items-center justify-between">
									<div class="font-semibold">Segment {segment.id}</div>
									<div class="flex gap-4 text-xs text-muted-foreground">
										<span>{segment.characterCount} characters</span>
										<span
											>{segment.sentenceCount}
											{segment.sentenceCount === 1 ? 'sentence' : 'sentences'}</span
										>
										<span
											class={segment.characterCount <= targetCharLimit
												? 'text-green-500 font-medium'
												: 'text-orange-500 font-medium'}
										>
											{segment.characterCount <= targetCharLimit ? 'Within limit' : 'Over limit'}
										</span>
									</div>
								</div>
								<p class="text-sm whitespace-pre-wrap">{segment.content}</p>
							</div>
						{/each}
					</div>
				</CardContent>
				<CardFooter class="flex gap-4">
					<Button onclick={downloadRefactored} disabled={segments.length === 0}>
						Download Refactored Text
					</Button>
					<Button onclick={copyToClipboard} variant="outline" disabled={segments.length === 0}>
						Copy to Clipboard
					</Button>
				</CardFooter>
			</Card>
		</div>
	{/if}

	<!-- Instructions (shown when no text) -->
	{#if !hasProcessed && segments.length === 0}
		<Card>
			<CardHeader>
				<CardTitle>How Refactoring Works</CardTitle>
			</CardHeader>
			<CardContent>
				<div class="space-y-4 text-sm text-muted-foreground">
					<div class="flex gap-3">
						<div
							class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary text-primary-foreground font-semibold"
						>
							1
						</div>
						<div>
							<p class="font-medium text-foreground mb-1">Paste Your Full Document</p>
							<p>
								Include everything: story title, metadata, segments, and storyboards. The tool will
								only process the segmented section.
							</p>
						</div>
					</div>
					<div class="flex gap-3">
						<div
							class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary text-primary-foreground font-semibold"
						>
							2
						</div>
						<div>
							<p class="font-medium text-foreground mb-1">Set Start and End Markers</p>
							<p>
								Define where segmentation begins (e.g., "**Segment 1:**") and ends (e.g., "---").
								Content outside these markers is preserved.
							</p>
						</div>
					</div>
					<div class="flex gap-3">
						<div
							class="flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-primary text-primary-foreground font-semibold"
						>
							3
						</div>
						<div>
							<p class="font-medium text-foreground mb-1">Process & Download</p>
							<p>
								Review the refactored segments with corrected character counts, then download or
								copy the complete document.
							</p>
						</div>
					</div>
					<div class="mt-6 rounded-lg bg-muted p-4">
						<p class="font-medium text-foreground mb-2">Example Input:</p>
						<pre class="text-xs overflow-x-auto whitespace-pre-wrap">## Story 1: "The Title"

**Segment 1:** (487 characters)
Text here with incorrect count...

**Segment 2:** (512 characters)
More text...

---

### Storyboard Images
(This section won't be re-segmented)</pre>
					</div>
					<div class="rounded-lg bg-blue-500/10 border border-blue-500/20 p-4">
						<p class="font-medium text-foreground mb-2">ðŸ’¡ Pro Tip:</p>
						<p class="text-xs">
							The tool uses the same smart chunking algorithm as the main mode, so sentences are
							never broken mid-way. No tolerance setting is needed!
						</p>
					</div>
				</div>
			</CardContent>
		</Card>
	{/if}
</div>
